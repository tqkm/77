数据库
---
#### ACID特性<br>
原子性：一个事物的一系列操作，要么全部成功，要么全部失败，不存在中间态<br>
一致性：事务开始前到事务结束后，数据库的完整性不会变<br>
隔离性:一个事务的操作不会影响另一个事务<br>
持久性：事务一旦提交，对数据库的影响就是永久性的<br>
#### 隔离级别<br>
Readuncommitted:读未提交，一个事务可以读取到另一个事务未提交的数据，即产生脏读(不可重复读、幻读更会有)<br>
Readcommitted:读已提交，可以有效防止脏读，同时也是oracle和postgresql默认的事务隔离级别，会产生不可重复读，比如事务A读取了某一条数据为A，事务B也读取了该条数据并且修改为B且提交事务，事务A再次读取该条数据发现数据变了<br>
Repeatable read:可重复读,mysql的默认隔离级别，可以防止不可重复读，但是会产生幻读，比如事务A读取了满足某一条件的数据共n行，事务B添加了满足该条件的数据m行，此时事务A再次读取发现成了m+n行<br>
Seriablizable:串行化，所有的操作按照一定的顺序执行，对数据性能影响极大，一般不会使用<br>
### Mysql
视图：根据编写的查询sql语句所建立的一张数据表，但并不存储数据，对该视图可通过sql直接进行查询，可以减少代码中的sql复杂度。基本格式为：
create view as 视图名（列名，列名）as select...(sql查询语句) <br>
mysql引擎有多种，主要使用的就是myisam和innodb，默认的是innodb<br>
myisam：不支持事务，只支持表锁，适合于读操作多写操作少的场景,支持非聚簇索引，数据结构为B+Tree,存储的是数据的地址，不支持外键，支持全文索引<br>
innodb：支持事务，支持表锁、行级锁，支持聚簇索引，数据结构为B+Tree，存储的是具体的数据，支持外键，不支持全文索引<br>
mysql集群如何实现主从复制：主库将写操作记录到二进制文件中，开启一个IO线程发送给从库，从库开启一个IO线程接受，并将二进制文件读取到本地的中继日志中，再开启一个sql线程，读取中继日志并修改数据库<br>

<h3>join</h3>
join有内连接，外连接，左连接，右连接，自然连接，理解join，首先了解一下笛卡尔积，比如A表有m条数据，B表有n条数据，笛卡尔积产生的数据就有m * n条<br>
内连接：select a.*,b.* from A a (inner) join B b where ... 相当于求AB的交集<br>
左连接：select a.*,b.* from A a left join B b where ... 求AB表的交集，并且A表所有数据，不存在的输出null<br>
右连接：select a.*,b.* from A a right join B b where ... 求AB表的交集，并且B表所有数据，不存在的输出null<br>
外连接：select a.*,b.* from A a outter join B b where ... 求AB的并集，mysql不支持外链，可以用inner连接左连接与右连接<br>
自然连接：select a.*,b.* from A a，B b where ... <br>

sql优化:<br>
小表驱动大表:数据库中表连接算法有个Nested Loop Join（NLJ）算法，即双层嵌套循环，外层的是驱动表，内层的是被驱动表，驱动表查找一条数据，在被驱动表中逐一匹配，所以A表100条数据，B表10000条数据，如果是A驱动B（A.=B.）,数据库连接需要100次，反之就是10000次，所以应该数据少的驱动数据大的

